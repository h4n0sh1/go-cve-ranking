package main

import(
	"fmt"
	"io"
	"log"
	"net/http"
	"regexp"
	"os"
	"sort"
	"strconv"
)

type CWE struct{
	ID		string
	Score		float64
	Sv		float64
	Fr		float64
	Freq		float64
	MapCVE		map[string]string
	ListCVE		[]CVE
}

type CVE struct{
	name string
	cvss float64
}

type ListCVE []CVE

type MitreMap map[string]float64

func (lst ListCVE) String() string{
	str := ""
	for _, v := range lst{
		str += fmt.Sprintf("%v, %f -> ", v.name, v.cvss)
	}
	return fmt.Sprintf("%v", str)
}

func (cwe CWE) String() string{
	return fmt.Sprintf("CWE-%s, Score: %v, CVE: %v \n\n", cwe.ID, cwe.Score, cwe.ListCVE )
}


// MitreScore(id1) > MitreScore(id2) ? True 
func (m MitreMap) compareMitre(id1,id2 string) bool{
	if _, test := m[id1]; !test{
		return false
	}else if _, test := m[id2]; !test{
		return true
	}else{
		return m[id1] > m[id2]
	}
}

func collectMitre() MitreMap{
	map_score := make(map[string]float64)
	url := "https://cwe.mitre.org/top25/archive/2020/2020_cwe_top25.html"
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	// Top 40
	re := regexp.MustCompile(`\/definitions\/[0-9]{1,5}\.html"\ title=.*>CWE-([0-9]{1,5}) *\<.*center;"\>([0-9.]*)`)
	match := re.FindAllSubmatch(body,-1)
	for _, m := range match{
		//fmt.Println("Matching: ", string(m[1]), string(m[2]))
		sc, _ := strconv.ParseFloat(string(m[2]),64)
		map_score[string(m[1])] = sc
	}
	return map_score
}

func (cwe * CWE) analyzeMetadata(size int){
	cve_lst := make([]CVE, 0)
	for id, sc := range cwe.MapCVE {
		fl, _ := strconv.ParseFloat(sc,64)
		cve_lst = append(cve_lst, CVE{id,fl})
	}
	// Reverse order - High to low
	sort.Slice(cve_lst, func(i,j int) bool{return cve_lst[i].cvss > cve_lst[j].cvss})
	cwe.ListCVE = cve_lst

	// Calculate Frequency 
	cwe.Freq = float64(len(cwe.ListCVE))/float64(size)

	/* Calculate Sv according to MITRE : 
	 Sv(CWE_X) = (average_CVSS_for_CWE_X - min(CVSS)) / (max(CVSS) - min(CVSS))
	*/
	Max := cwe.ListCVE[0].cvss
	Min := cwe.ListCVE[len(cwe.ListCVE)-1].cvss
	if(Max == Min){
		cwe.Sv = Max
	}else{
		Avg := 0.0
		for _, v := range cwe.ListCVE{
			Avg += v.cvss
		}
		Avg /= float64(len(cwe.ListCVE))
		cwe.Sv = (Avg - Min) / (Max - Min)
	}

	//fmt.Println("Frequency :", cwe.Freq, "Score", cwe.Sv)
	//fmt.Printf("Min %v, Max %v, Avg, %v \nLen-cve %v, Size %v \n", Min, Max, Avg,len(cwe.ListCVE), size)
}

func extractMetadata(cve_lst [][][]byte)(map[string]CWE, int){
	m := make(map[string] CWE)
	nocwe_lst := make([]string, 0)
	for _, lst := range cve_lst{
		/* CVE Individual Analysis */
		cve := string(lst[1])
		resp, err := http.Get("http://127.0.0.1:1323/cves/" + cve)
		if err != nil {
			log.Fatal(err)
		}
		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			log.Fatal(err)
		}
		//fmt.Printf("Body = %v", string(body))
		re := regexp.MustCompile(`([{,}])`)
		body = re.ReplaceAll(body, []byte("${1}\r\n"))
		re = regexp.MustCompile(`CWE-([0-9]+)`)
		match := re.FindAllSubmatch(body, -1)
		if len(match) > 0{
			// TO-DO : 0 -> i for multiple CWE in one CVE
			cwe_id := string(match[0][1])
			re = regexp.MustCompile(`BaseScore": *([0-9.]+)`)
			match := re.FindAllSubmatch(body, -1)
			// CVSS3
			BaseScore := string(match[1][1])
			if BaseScore == "0" {
				// CVSS2
				BaseScore = string(match[0][1])
			}
			if _, found := m[cwe_id]; !found{
				m[cwe_id] = CWE{cwe_id,0,0,0,0,make(map[string]string),make([]CVE,0)}
			}
			m[cwe_id].MapCVE[cve] = BaseScore
			//fmt.Printf("%s, Regex: %s\n",cve, string(match[0][0]))
		}else{
			nocwe_lst = append(nocwe_lst, cve)
		}
	}
	fmt.Printf("Identified %d non defined cwes\n", len(nocwe_lst))
	size := len(cve_lst) - len(nocwe_lst)
	return m, size
}

func main(){
	fmt.Println("CVE-RANK")
	url := "https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword="
	if len(os.Args) < 2 {
		log.Fatal("You must specify a search argument")
	} else{
		search := os.Args[1]
		url += search
	}
	fmt.Println(url)

	/* CVE Collection */
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		log.Fatal(err)
	}
	re := regexp.MustCompile(`\?name=(CVE-[0-9]{4}-[0-9]*)`)
	cve_lst := re.FindAllSubmatch(body,-1)
	for i:=0; i<len(cve_lst); i++{
		//fmt.Println(string(cve_lst[i][1]))
	}
	fmt.Println("Sucessfully Collected ", len(cve_lst), "vulnerabilities")

	/* CWE Dictionary Creation */
	cwe_map,size := extractMetadata(cve_lst)
	fmt.Printf("Initialized %T, Total CVE %v \n", cwe_map, size)
	MinFreq, MaxFreq := 1.0, 0.0
	for key, cwe := range cwe_map{
		cwe.analyzeMetadata(len(cwe_map))
		cwe_map[key] = cwe
		if MaxFreq < cwe.Freq  {
			MaxFreq = cwe.Freq
		}
		if MinFreq > cwe.Freq {
			MinFreq = cwe.Freq
		}
	}


	/* Calculate Final scores for each CWE */
	for key, cwe := range cwe_map{
		// Fr(CWE_X) = (count(CWE_X âˆˆ NVD) - min(Freq)) / (max(Freq) - min(Freq))
		cwe.Fr = (cwe.Freq - MinFreq) / (MaxFreq - MinFreq)
		cwe.Score = cwe.Fr * cwe.Sv * 100
		cwe_map[key] = cwe
	}

	/* Ranking */
	rank := make([]CWE, 0)
	for _, cwe := range cwe_map {
		rank = append(rank, cwe)
	}

	fmt.Println("Generating Mitre Map \n")
	mitre_map := collectMitre()
	//fmt.Println("MitreMap: ", mitre_map)

	// Rank by Score, then by Max CVE Score then by Mitre Generic Top 40 else equal
	sort.Slice(rank, func(i,j int) bool{
		if rank[i].Score == rank[j].Score {
			if rank[i].ListCVE[0].cvss == rank[j].ListCVE[0].cvss {
				return mitre_map.compareMitre(rank[i].ID, rank[j].ID)
			} else {
				return rank[i].ListCVE[0].cvss > rank[j].ListCVE[0].cvss
			}
		}else {
			return rank[i].Score > rank[j].Score
		}
	})

	for _, cwe := range rank{
		fmt.Println(cwe)
	}
}
